/* globals test, expect */
const path = require('path');
const jscodeshift = require('jscodeshift');
const codeMod = require('../suppress-eslint-errors');

test('inserts a new comment in javascript', () => {
	const program = `export function foo(a, b) {
  return a == b;
}
`;

	expect(modifySource(program, { rules: 'eqeqeq' })).toBe(`export function foo(a, b) {
  // TODO: Fix this the next time the file is edited.
  // eslint-disable-next-line eqeqeq
  return a == b;
}
`);
});

test("doesn't update unnecessarily", () => {
	const program = `export default function foo(a, b) {
		// TODO: Fix this the next time the file is edited.
		// eslint-disable-next-line eqeqeq
		return a == b;
	}
	`;

	expect(modifySource(program)).toBe(undefined);
});

test('inserts a new comment in jsx', () => {
	const program = `export function Component({ a, b }) {
  return (
    <div>
      <div>{a == b}</div>
    </div>
  );
}`;

	expect(modifySource(program, { rules: 'eqeqeq' })).toBe(`export function Component({ a, b }) {
  return (
    <div>
      {/* TODO: Fix this the next time the file is edited. */}
      {/* eslint-disable-next-line eqeqeq */}
      <div>{a == b}</div>
    </div>
  );
}`);
});

test('updates an existing comment in javascript', () => {
	const program = `export function foo(a, b) {
  // eslint-disable-next-line eqeqeq
  var bar = a == b;
}
`;

	expect(modifySource(program, { rules: 'no-unused-vars' })).toBe(`export function foo(a, b) {
  // eslint-disable-next-line eqeqeq, no-unused-vars
  var bar = a == b;
}
`);
});

test('updates an existing comment in jsx', () => {
	const program = `export function Component({ a }) {
  return (
    <div>
      {/* eslint-disable-next-line eqeqeq */}
      <div>{a == c}</div>
    </div>
  );
}`;

	expect(modifySource(program, { rules: 'no-undef' })).toBe(`export function Component({ a }) {
  return (
    <div>
      {/* eslint-disable-next-line eqeqeq, no-undef */}
      <div>{a == c}</div>
    </div>
  );
}`);
});

// I discovered this edge case in testing, and it's sufficiently rare that I don't feel like
// *actually* handling it properly now; however, it should at least not crash.
test("doesn't crash on unusual markup", () => {
	const program = `export default function Component({ a, b }) {
  return (
    <div>
      <div>
      </div>{a == b}
    </div>
  );
}`;

	expect(modifySource(program)).toBe(program);
});

// This is a somewhat more common case that crashed when I first encountered it.
// Unfortunately, it's not legal to put comments between props, so fixing this one
// will be rather tricky.
test("doesn't crash on violations in multiline props", () => {
	const program = `export default function Component({ a, b }) {
    return (
      <div
        prop={a == b ? a : b}>
      </div>
    );
  }`;

	expect(modifySource(program)).toBe(program);
});

test('supports alternative messages in javascript', () => {
	const program = `export function foo(a, b) {
  return a == b;
}
`;

	expect(modifySource(program, { message: 'Something more informative', rules: 'eqeqeq' }))
		.toBe(`export function foo(a, b) {
  // Something more informative
  // eslint-disable-next-line eqeqeq
  return a == b;
}
`);
});

test('supports alternative messages in jsx', () => {
	const program = `export function Component({ a, b }) {
  return (
    <div>
      <div>{a == b}</div>
    </div>
  );
}`;

	expect(modifySource(program, { message: 'Something more informative', rules: 'eqeqeq' }))
		.toBe(`export function Component({ a, b }) {
  return (
    <div>
      {/* Something more informative */}
      {/* eslint-disable-next-line eqeqeq */}
      <div>{a == b}</div>
    </div>
  );
}`);
});

test('supports rule whitelist in javascript', () => {
	const program = `export function foo(a, b) {
  return a == b;
  console.log('unreachable');
}
`;

	expect(modifySource(program, { rules: 'no-unreachable' })).toBe(`export function foo(a, b) {
  return a == b;
  // TODO: Fix this the next time the file is edited.
  // eslint-disable-next-line no-unreachable
  console.log('unreachable');
}
`);
});

// Ensures when `"loc"` is `null` on a node but that the node is still traversed upward to find its
// parent.
//
// Example section of AST generated by the code in this test where `loc` is `null`:
//
// ```
// "body": [
//   {
//     "type": "ExportNamedDeclaration",
//     "start": 0,
//     "end": 55,
//     "loc": { ... },
//     "declaration": {
//       "type": "VariableDeclaration",
//       "start": 7,
//       "end": 55,
//       "loc": null,  ************************ <- null!! ***************************
//       "declarations": [
//         {
//           "type": "VariableDeclarator",
//           "start": 13,
//           "end": 55,
//           "loc": {
//             "start": { "line": 1, "column": 13, "token": 2 },
//             "end": { "line": 3, "column": 1, "token": 17 },
// ```
test('comments named export with correct syntax', () => {
	const program = `export const Component = (a, b) => {
  return a == b;
}`;

	expect(modifySource(program, { rules: 'import/prefer-default-export' }))
		.toBe(`// TODO: Fix this the next time the file is edited.
// eslint-disable-next-line import/prefer-default-export
export const Component = (a, b) => {
  return a == b;
}`);
});

const defaultPath = path.resolve(__dirname, 'examples', 'index.js');
function modifySource(source, options) {
	return codeMod(
		{
			source,
			path: defaultPath,
		},
		{ jscodeshift, j: jscodeshift, report: console.log },
		options || {}
	);
}
